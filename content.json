[{"title":"NodeSchool learnyounode答案(转载)","date":"2017-04-20T09:41:35.000Z","path":"2017/04/20/learnyounode-result/","text":"","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"ES5中bind()函数要点总结","date":"2017-04-20T09:06:07.000Z","path":"2017/04/20/bind-learning/","text":"ES5中bind函数的特性: 权威参考MDN 语法：fun.bind(thisArg[,arg1[,arg2[,...]]])参数：thisArg:当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new操作符调用时绑定函数时，该参数无效。arg1,arg2,...:当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。返回值：返回由指定的this值和初始化改造的原函数拷贝 1.预设参数：不同于call和apply只是单纯的设置this的值后传参，它还会将所有bind()方法中的实参（第一个参数之后的参数）与this一起绑定。eg1:12345var sum = function(x,y)&#123; return x+y;&#125;var succ = sum.bind(null,1) //让this指向null,其后的实参也会作为实参传入被绑定的函数sumsucc(2); //输出3，可以看到1绑定了sum函数中的x eg2:1234567var copy = function()&#123; var args = Array.prototype.slice.call(arguments); console.log(args.join());&#125;copy(&quot;hi&quot;,&quot;friends&quot;) //输出 hi,friendsvar after = copy.bind(null,&quot;hi&quot;,&quot;welcome&quot;);after(&quot;dear&quot;,&quot;friend&quot;); //输出 hi,welcome,dear,friend 2.bind()方法所返回的函数的length（形参数量）等于原函数的形参量减去传入bind()方法中的实参数量（除去第一个表示作用域的参数），因为传入到bind中的实参都会绑定到原函数的形参eg:123function func(a,b,c,d,e)&#123;...&#125; //func.length = 5var after = func.bind(null,1,2); //这里传入两个实参绑定到了func函数的a,bconsole.log(after.length) //输出为3 注意：这里bind()方法的第一个参数为null，是因为func()函数内部没有任何与上下文相关的代码，所以不需要传递上下文对象 3.当bind()所返回的函数用作构造函数时，传入bind()的this将被忽略，实参会全部传入原函数eg:1234567891011var person=function(y)&#123; this.name=&quot;Amy&quot;, this.printName=function()&#123;console.log(this.name+&quot; &quot;+y)&#125;&#125;var anotherPerson=&#123; name:&quot;Bob&quot;&#125;var Test = person.bind(anotherPerson,&quot;Jack&quot;);var test = new Test(); //或者var test = new(Test);console.log(test.name) //输出 &quot;Amy&quot;console.log(test.printName()) // 输出&quot;Amy Jack&quot; 可以看到，Test为一个绑定函数，传入了anotherPerson作为上下文对象，传入了“Jack”作为预设参数，使用new调用Test时，传入的this完全被忽略，但是预设的实参能够被传入 4.bind()方法返回的是一个带有固定作用域的新函数，以后不管在哪儿调用这个新函数，都不用担心作用域的问题，即使是之后再使用call函数作用于这个新函数，也不会改变函数执行的上下文对象 eg: 1234567891011121314151617var name = &quot;Global&quot;;var student = &#123; name:&quot;John&quot;&#125;var person = &#123; name:&quot;Amy&quot;, sayName:function()&#123;console.log(this.name)&#125;&#125;var one=&#123; name:&quot;Bob&quot;&#125;var sayName = person.sayName;var bindSayName = person.sayName.bind(student);console.log(person.sayName()) // &quot;Amy&quot;console.log(sayName()) // &quot;Global&quot;console.log(bindSayName()) //&quot;John&quot;console.log(bindSayName.call(one)) //&quot;John&quot; 此时bindSayName这个函数已经绑定到了student这个上下文，接下来用call调用它也不会改变上下文对象 5.配合setTimeout和setInterval函数使用一般在函数或类的实例中使用setTimeout和setInterval函数时，this会默认指向window对象，所以这时需要显示的绑定this对象 eg: 123456789var name = &quot;Global&quot;;var person = &#123; name:&quot;Amy&quot;, sayName:function()&#123;console.log(this.name)&#125;, printName:function()&#123; setTimeout(this.sayName,1000); &#125;&#125;console.log(person.printName()) //&quot;Global&quot; 出现上述问题的原因是setTimeout把person的printName函数放到全局函数作用域中执行去了，所以打印的是全局作用域中的name变量,故而需要手动的在setTimeout函数中绑定this对象，改进如下： 123456789var name = &quot;Global&quot;;var person = &#123; name:&quot;Amy&quot;, sayName:function()&#123;console.log(this.name)&#125;, printName:function()&#123; setTimeout(this.sayName.bind(this),1000); &#125;&#125;console.log(person.printName()) //&quot;Amy&quot; 6.兼容性问题：bind()是在ES5中加入的新特性，所以无法在所用浏览器上运行，例如IE6、7、8都不支持，因此需要手动的实现bind()函数 贴出polyfill官方文档上的实现：12345678910111213141516171819202122if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), //(1) fToBind = this, //(3) fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP? this: oThis ||this, aArgs.concat(Array.prototype.slice.call(arguments))); //(2) &#125;; fNOP.prototype = this.prototype; //(4) fBound.prototype = new fNOP(); //(5) return fBound; &#125;;&#125; 理解：以1中的eg2举个例子：1234567var copy = function()&#123; var args = Array.prototype.slice.call(arguments); console.log(args.join());&#125;copy(&quot;hi&quot;,&quot;friends&quot;) //输出 hi,friendsvar after = copy.bind(null,&quot;hi&quot;,&quot;welcome&quot;);after(&quot;dear&quot;,&quot;friend&quot;); //输出 hi,welcome,dear,friend (1) aArgs是定义bind函数时传入的除第一个参数oThis之外的预设参数，在eg2中为[“hi”,”welcome”](2) 这里的arguments是bind绑定后返回的函数after调用时传入的参数，其是类数组对象，调用Array.prototype.slice.call(arguments)后转化为数组，在eg2中为[“dear”,”friend”](3) 这里的fToBind就是被绑定的原来的函数”copy”(4) 本来fBound.prototype = fToBind.prototype就可以让新函数after继承原来函数copy的所有属性，但这样新函数和原来被绑定的函数指向同一个地方，对新函数的任何修改会影响到原来被绑定的那个函数，不符合要求，所以引入fNOP这个函数作为中转，让bind绑定后返回的函数fBound指向继承了被绑定的函数fToBind的所有属性的一个新的函数fNOP，此时之后对fBound函数做的修改只会影响fNOP这个函数，而与fToBind没有任何关系","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ES5","slug":"ES5","permalink":"http://yoursite.com/tags/ES5/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"js判断数据是否为数组类型","date":"2017-04-19T15:43:05.000Z","path":"2017/04/19/is-array/","text":"1.instanceof12var a=[];console.log(a instanceof Array) //输出true 2.原型链方法constructor123var arr=[1,2,3]console.log(arr.constructor==Array) //输出为trueconsole.log(arr.__proto__.constructor==Array) //和上面一样，输出为true 注意： (1) __proto__在低版本IE中是没有定义的 (2) instanceof 和constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false 原因： (1) array属于引用型数据，在传递过程中，仅仅是引用地址的传递 (2) 每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array 3.通用方法12345var arr = [12,3,5]function isArray(o)&#123; return Object.prototype.toString.call(o)==&apos;[object Array]&apos;;&#125;console.log(isArray(arr)) //true 4.ES5定义了方法Array.isArray()来判断1Array.isArray([]); //true 比较新，有些浏览器不支持","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"水平居中和垂直居中","date":"2017-04-18T14:02:34.862Z","path":"2017/04/18/center/","text":"html页面结构如下，仅讨论块状元素的居中问题，div的父元素为body，改成其他元素同理12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DIV仅水平居中让一个DIV水平居中，直接用CSS就可以做到。 为了让div能够看到，我们需要为其设置颜色和高度才能在页面可见，宽度如果不设置默认是继承父元素的宽度 只要设置了DIV的宽度，然后使用margin设置边距0 auto或者auto，CSS自动算出左右边距，使得DIV居中。123456#mydiv&#123; margin:0 auto; width:400px; height:200px; background:#ccc;&#125; 水平居中效果如下： DIV水平和垂直都居中 绝对定位法 1234567891011#mydiv&#123; width:400px; height:200px; background:#ccc; position:absolute; margin:auto; left:0; right:0; top:0; bottom:0;&#125; 负边距补全法此法要让DIV水平和垂直居中，必需知道该DIV的宽度和高度，然后设置定位为绝对定位，距离页面窗口左边框和上边框的距离设置为50%，这个50%就是指页面窗口的宽度和高度的50%，最后将该DIV分别左移和上移，左移和上移的大小就是该DIV宽度和高度的一半。 123456789#mydiv&#123; position:absolute; width:400px; height:200px; background:#ccc; left:50%; top:50%; margin:-100px 0 0 -200px;&#125; 注意：这儿的负边距补充也可以使用css3的transform属性实现：123456789#mydiv&#123; position:absolute; width:400px; height:200px; background:#ccc; left:50%; top:50%; transform:translate(-50%,-50%);&#125; 1,2的效果如下：","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"ssh-key git多账户配置","date":"2017-04-18T13:40:06.722Z","path":"2017/04/18/ssh key-gen/","text":"场景：在使用git的时候，一般我们使用的远程Git服务器是github，这时只需简单的生成ssh-key密钥对并将公钥添加到github中就可以使用ssh了。 但在公司开发使用内部的git时，一般在gitlab,使用的邮箱一般是公司的邮箱，那么就需要配置多个ssh-key账户了。假设user使用github的邮箱为user1@163.com;user2使用gitlab的邮箱为user2@163.com,下面是配置过程： 首先进入用户主目录下的.ssh文件夹，我们生成的密钥对放在这儿1$ cd ~/.ssh 分别为user1和user2生成密钥对：默认三次回车生成key的名字为id_rsa，注意在生成第二个的时候不要使用默认名，否则会覆盖第一个，在以下位置为第二个输入名字12345#新建SSH key$ ssh-keygen -t rsa -C &quot;user1@163.com&quot;$ ssh-keygen -t rsa -C &quot;user2@163.com&quot;#设置user2的命名为id_rsa_work Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_work 此时在.ssh目录下就有两个密钥对文件id_rsa和id_rsa_work,我们将公钥分别拷至对应的Git服务器 添加key到SSH agent中:此时还无法使用第二个服务器，因为Git会默认只读取到id_rsa,为了让SSH识别新的私钥，需将其添加到SSH agent中：12$ ssh-add ~/.ssh/id_rsa$ ssh-add ~/.ssh/id_rsa_work 如果出现Could not open a connection to your authentication agent的错误，就试着用以下命令：123$ ssh-agent bash$ ssh-add ~/.ssh/id_rsa$ ssh-add ~/.ssh/id_rsa_work 成功会显示：1Identity added: /c/Users/Windows用户名/.ssh/key名 (/c/Users/Windows用户名/.ssh/key名) 注意：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了。 创建并配置config文件使配置永久生效：在.ssh目录下新建一个文本文件，命令为config，不需要后缀，bash下可直接使用touch config,编辑以下内容： 12345678910111213# gitlab Host gitlab的IP HostName gitlab的Host //这里填你们公司的git网址即可 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_work User user2# github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa User user1 其规则就是：从上至下读取config的内容，在每个Host下寻找对应的私钥。按照你的情况修改就可以。 使用：如果之前有设置全局用户名和邮箱的话，需要unset一下，可通过 $ git config --list来查看全局配置 12$ git config --global --unset user.name$ git config --global --unset user.email 可以在不同的仓库下设置局部的用户名和邮箱用不同的账号登录，比如在公司的repository下: 12$ git config user.name &quot;user2&quot; $ git config user.email &quot;user2@163.com&quot; 测试： 1234$ ssh -T git@github.com#输出：Hi user1! You&apos;ve successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@gitlab的IP#输出：Hi user2@163.com**, this is git@..... 测试成功。如果出什么问题，可以通过ssh -vT git@github.com来输出编译信息，然后根据编译信息去解决问题","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"工作流","slug":"工作流","permalink":"http://yoursite.com/tags/工作流/"}]},{"title":"Hello World","date":"2017-04-13T13:26:34.908Z","path":"2017/04/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]